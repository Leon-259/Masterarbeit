\clearpage
\section*{Feature-Extraktion aus den Trajektoiren}

\begin{pythoncodeAnhang}{Feature-Extraktino aus den Trajektorien mit \textit{Numba} just-in-time Kompilierung.}
@staticmethod
@jit(nopython=True, parallel=True, cache=True)
def __get_features(self, trajIDs, frames, unixtimestamps, x_vals, y_vals):
    trajIDmax = np.nanmax(trajIDs)

    geschwindigkeiten = np.full((trajIDmax, 1), np.nan, np.float32)
    beschleunigungen = np.full((trajIDmax, 1), np.nan, np.float32)
    stepCount = np.full((trajIDmax, 1), np.nan, np.float32)
    distanzen = np.full((trajIDmax, 1), np.nan, np.float32)
    strecken = np.full((trajIDmax, 1), np.nan, np.float32)
    kurvigkeiten = np.full((trajIDmax, 1), np.nan, np.float32)
    x_geschw = np.full((trajIDmax, 1), np.nan, np.float32)
    y_geschw = np.full((trajIDmax, 1), np.nan, np.float32)

    for id in prange(trajIDmax):
    #for id in range(trajIDmax):
        idx = np.atleast_1d(np.where(trajIDs == id)[0]) #hole die indizes der eintr채ge von der trajektorie mit der ID=id
        
        if idx.size == 0: continue # wenn keine eintr채ge mit dieser ID vorhanden sind 체berspringe alles weitere (Nur sicherheitsmasnahme)
        
        framesTraj = frames[idx]                        # FrameIDs zu den Frames, in denen die Trajektorie aktiv war
        unixtimestampsTraj = unixtimestamps[idx]        # Unixtimestamps in denen die Trajektorie messwerte hat
        x_valsTraj = x_vals[idx]                        # X-koordinaten der Bbox mittelpunkte der positionen
        y_valsTraj = y_vals[idx]                        # Y-koordinaten der Bbox mittelpunkte der positionen
        x_diffsTraj = np.diff(x_valsTraj)               # Differenzen der x koordinaten
        y_diffsTraj = np.diff(y_valsTraj)               # Differenzen der y koordinaten 
        timeDiffsTraj = np.diff(np.divide(unixtimestampsTraj, 1000))        # Zeitschritte in sekunden
        streckeStepsTraj = np.sqrt((x_diffsTraj**2) + (y_diffsTraj**2))     #Zur체ckgelegte distanzen in den einzelnen schritten
        geschwindigkeitenTraj = np.divide(streckeStepsTraj, timeDiffsTraj)
        beschleunigungenTraj = np.divide(geschwindigkeitenTraj, timeDiffsTraj)
        
        ### GESCHWINDIGKEITEN ###
        if geschwindigkeitenTraj.size == 0:
            geschwindigkeiten[id] = np.nan  
        else:  
            geschwindigkeiten[id] = np.nanmean(geschwindigkeitenTraj)
        ### BESCHLEUNIGUNGEN ###
        if beschleunigungenTraj.size == 0:
            beschleunigungen[id] = np.nan    
        else:
            beschleunigungen[id] = np.nanmean(beschleunigungenTraj)
        ### SCHRITTANZAHL ###
        if framesTraj.size != 0:
            stepCount[id] = framesTraj.size 
        else:
            stepCount[id] = np.nan
        ### DISTANZ ###
        if x_diffsTraj.size == 0 and y_diffsTraj == 0:
            distanzen[id] = np.nan    
        else:
            distanzen[id] = np.sqrt((np.nansum(x_diffsTraj)**2) + (np.nansum(y_diffsTraj)**2))    #Euclidischer abstand von startpunkt zu endpunkt
        ### STRECKE ###
        if streckeStepsTraj.size == 0:
            strecken[id] = np.nan
        else:    
            strecken[id] = np.nansum(streckeStepsTraj)
        ### KURVIGKEIT ###
        if np.isnan(distanzen[id]) or np.isnan(strecken[id]) or distanzen[id] == 0:
            kurvigkeiten[id] = np.nan
        elif strecken[id] < 2*np.max(framesTraj):       #bewegt sich das tier nicht, dann wird keine Kurvigkeit ermittelt. 2 Pix Lokalisationsschwankung pro frame ist die schranke
            kurvigkeiten[id] = 1
        else:
            kurvigkeiten[id] = strecken[id]/distanzen[id]
        ### X_GESCHWINDIGKEIT ###
        if x_diffsTraj.size == 0 or timeDiffsTraj.size == 0:
            x_geschw[id] = np.nan
        else:
            x_geschw[id] = np.nansum(x_diffsTraj)/np.nansum(timeDiffsTraj)
        ### Y_GESCHWINDIGKEIT ###
        if y_diffsTraj.size == 0 or timeDiffsTraj.size == 0:
            y_geschw[id] = np.nan
        else:
            y_geschw[id] = np.nansum(y_diffsTraj)/np.nansum(timeDiffsTraj)

    meanGeschwindigkeiten = np.nanmean(geschwindigkeiten)
    stdGeschwindigkeiten = np.nanstd(geschwindigkeiten)
    maxGeschwindigkeiten = np.nanmax(geschwindigkeiten)
    minGeschwindigkeiten = np.nanmin(geschwindigkeiten)

    meanBeschleunigungen = np.nanmean(beschleunigungen)
    stdBeschleunigungen = np.nanstd(beschleunigungen)
    maxBeschleunigungen = np.nanmax(beschleunigungen)
    minBeschleunigungen = np.nanmin(beschleunigungen)

    meanStepCount = np.nanmean(stepCount)
    stdStepCount = np.nanstd(stepCount)
    minStepCount = np.nanmin(stepCount)

    meanDistanzen = np.nanmean(distanzen)
    stdDistanzen = np.nanstd(distanzen)
    maxDistanzen = np.nanmax(distanzen)

    meanStrecken = np.nanmean(strecken)
    stdStrecken = np.nanstd(strecken)
    maxStrecken = np.nanmax(strecken)
    minStrecken = np.nanmin(strecken)
    totalStrecke = np.nansum(strecken)

    meanKurvigkeiten = np.nanmean(kurvigkeiten)
    stdKurvigkeiten = np.nanstd(kurvigkeiten)
    maxKurvigkeiten = np.nanmax(kurvigkeiten)

    x_drift = np.nansum(x_geschw)
    y_drift = np.nansum(y_geschw)
    drift_geschw = np.sqrt((x_drift**2) + (y_drift**2))

    return  meanGeschwindigkeiten, \
            stdGeschwindigkeiten, \
            maxGeschwindigkeiten, \
            minGeschwindigkeiten, \
            meanBeschleunigungen, \
            stdBeschleunigungen, \
            maxBeschleunigungen, \
            minBeschleunigungen, \
            meanStepCount, \
            stdStepCount, \
            minStepCount, \
            meanDistanzen, \
            stdDistanzen, \
            maxDistanzen, \
            meanStrecken, \
            stdStrecken, \
            maxStrecken, \
            minStrecken, \
            totalStrecke, \
            meanKurvigkeiten, \
            stdKurvigkeiten, \
            maxKurvigkeiten, \
            drift_geschw
\end{pythoncodeAnhang}